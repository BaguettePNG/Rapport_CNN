\section{Présentation du fonctionnement des fonctions}

\subsection{Interface MicroProcesseur}

Dans cette partie, nous avons initié une séance de travaux pratiques pour nous familiariser avec 
le logiciel HDL Designer. Le programme «Interface Microprocesseur», préalablement implémenté par 
les enseignants, respecte strictement les données présentées dans le TD et développées dans les 
sections précédentes du rapport. Nous allons l’étudier en détail afin de démontrer sa correspondance 
avec le modèle théorique.
\newline

Pour rappel, l’interface Microprocesseur a été conçue selon une machine séquentielle, tandis que 
la partie commande a été développée sur le modèle d’une machine de Mealy. Le code présenté respecte 
rigoureusement la structure des blocs : réseau combinatoire d’entrée, réseau combinatoire de sortie 
et registres correspondant à la machine à états.
\newline

Voici le tableau récapitulant les entrées et sorties du bloc Interface Microprocesseur complet :

\begin{table}[h!]
\centering
\begin{tabular}{|l||c|l|}
\hline
\textbf{Signal} & \textbf{Direction} & \textbf{Type} \\ \hline
Cnd        & IN     & std\_logic \\ \hline
EtatLu     & IN     & std\_logic\_vector(7 DOWNTO 0) \\ \hline
H          & IN     & std\_logic \\ \hline
OctetLu    & IN     & std\_logic\_vector(7 DOWNTO 0) \\ \hline
RnW        & IN     & std\_logic \\ \hline
nCS        & IN     & std\_logic \\ \hline
nRST       & IN     & std\_logic \\ \hline
DecNbOctet & OUT    & std\_logic \\ \hline
EtatLu\_RST & OUT   & std\_logic \\ \hline
M\_Received & OUT   & std\_logic \\ \hline
OctetLu\_RD & OUT   & std\_logic \\ \hline
SelAdr     & OUT    & std\_logic\_vector(7 DOWNTO 0) \\ \hline
D07        & INOUT  & std\_logic\_vector(7 DOWNTO 0) \\ \hline
\end{tabular}
\caption{Signaux du module \texttt{Interface Microprocesseur}}
\label{tab:signaux_recepteurlin}
\end{table}


\subsubsection{Synchronisation des Entrées}

\begin{lstlisting}[style=VHDLStyle, caption={Reseau Cominatoire d'entrée}]
InputProc_Synchro :  PROCESS(H, nRST)
BEGIN
  IF (nRST='0') THEN 
    nCS_Synchro <= '1';
    RnW_Synchro <= '1';
    CnD_Synchro <= '1';
    D07_Synchro <= (others => '0');
  ELSIF (H'EVENT AND H='1') THEN
    nCS_Synchro <= nCS;
    RnW_Synchro <= RnW;
    CnD_Synchro <= CnD;
    D07_Synchro <= D07;
  END IF;
END PROCESS InputProc_Synchro;
\end{lstlisting}

Ce bloc VHDL gère la synchronisation des signaux provenant du microprocesseur. Le processus \texttt{InputProc\_Synchro} lit les signaux d’entrée à chaque front montant de l’horloge \texttt{H} et les initialise lors de la mise à zéro \texttt{nRST}. Les signaux synchronisés (\texttt{nCS\_Synchro, RnW\_Synchro, CnD\_Synchro, D07\_Synchro}) sont ensuite utilisés par le reste de l’interface.

\subsubsection{Réseau Combinatoire de Sortie}

\begin{lstlisting}[style=VHDLStyle, caption={Reseau Cominatoire de Sortie}]
OutputProc_Comb : PROCESS(nCS_Synchro, CnD_Synchro, RnW_Synchro, EtatCourant, OctetLu, EtatLu)
BEGIN
  D07 <= (others => 'Z');
  OctetLu_RD <= '0';
  EtatLu_RST <= '0';
  DecNbOctet <= '0';
  CASE EtatCourant IS
    WHEN Attente =>
      IF (nCS_Synchro='0' AND CnD_Synchro='0' AND RnW_Synchro='1') THEN
        OctetLu_RD <= '1';
      END IF;
    WHEN LectureData =>
      D07 <= OctetLu;
      IF (nCS_Synchro='1') THEN
        DecNbOctet <= '1';
      END IF;
    WHEN LectureEtat =>
      D07 <= EtatLu;
      IF (nCS_Synchro='1') THEN
        EtatLu_RST <= '1';
      END IF;
    WHEN EcritureFiltre =>   
    END CASE;
END PROCESS OutputProc_Comb;
\end{lstlisting}

Le processus \texttt{OutputProc\_Comb} contrôle la sortie des données et des états vers le microprocesseur. Il met à jour les signaux \texttt{D07, OctetLu\_RD, EtatLu\_RST, DecNbOctet} en fonction de l’état courant de la machine et des signaux synchronisés d’entrée. La logique combinatoire assure la correspondance entre les actions de lecture/écriture et l’état de la machine.

\subsubsection{Réseau Combinatoire d'Entrée}

\begin{lstlisting}[style=VHDLStyle, caption={Registres}]
ClockedProc : PROCESS(H, nRST)
BEGIN
  IF (nRST='0') THEN
    EtatCourant <= Attente;
  ELSIF (H'EVENT AND H='1') THEN
    EtatCourant <= EtatSuivant;
  END IF;
END PROCESS ClockedProc;

NextStateProc : PROCESS(nCS_Synchro, CnD_Synchro, RnW_Synchro, EtatCourant)
BEGIN
  EtatSuivant <= EtatCourant;
  CASE EtatCourant IS
  WHEN Attente =>
    IF (nCS_Synchro='0' AND CnD_Synchro='0' AND RnW_Synchro='1') THEN
      EtatSuivant <= LectureData;
    ELSIF (nCS_Synchro='0' AND CnD_Synchro='1' AND RnW_Synchro='1') THEN
      EtatSuivant <= LectureEtat;
    ELSIF (nCS_Synchro='0' AND CnD_Synchro='0' AND RnW_Synchro='0') THEN
      EtatSuivant <= EcritureFiltre;
    ELSE
      EtatSuivant <= Attente;
    END IF;
    WHEN LectureData =>
      IF (nCS_Synchro='1') THEN
        EtatSuivant <= Attente;
      ELSE
        EtatSuivant <= LectureData;
      END IF;
    WHEN LectureEtat =>
      IF (nCS_Synchro='1') THEN
        EtatSuivant <= Attente;
      ELSE
        EtatSuivant <= LectureEtat;
      END IF;
    WHEN EcritureFiltre =>
      IF (nCS_Synchro='1') THEN
        EtatSuivant <= Attente;
      ELSE 
        EtatSuivant <= EcritureFiltre;
      END IF;
  END CASE;
END PROCESS NextStateProc;
\end{lstlisting}

Les processus \texttt{ClockedProc} et \texttt{NextStateProc} implémentent la machine séquentielle. \texttt{ClockedProc} met à jour l’état courant à chaque front montant de l’horloge et réinitialise l’état au démarrage. \texttt{NextStateProc} définit l’état suivant selon les conditions des signaux d’entrée et l’état courant, en suivant la logique de la machine de Mealy.

\subsubsection{Réseau Synchronisé de Sortie}

\begin{lstlisting}[style=VHDLStyle, caption={Reseau Synchronisé de Sortie}]
OutputProc_Synchro : PROCESS(H, nCLR)
BEGIN 
  IF (nCLR='0') THEN
    SelAdr <= (others => '0');
  ELSIF (H'EVENT AND H='1') THEN 
    CASE EtatCourant IS 
    WHEN EcritureFiltre =>
      IF (nCS_Synchro='1') THEN
        SelAdr <= D07_Synchro;
      END IF;
    WHEN OTHERS =>
    END CASE;
  END IF;
END PROCESS OutputProc_Synchro;
  
M_Received <= EtatLu(4);

\end{lstlisting}

Le processus \texttt{OutputProc\_Synchro} synchronise la sélection d’adresse \texttt{SelAdr} avec l’horloge \texttt{H}. Il est actif principalement pendant l’état \texttt{EcritureFiltre}, assurant que les données de l’entrée \texttt{D07\_Synchro} sont correctement mémorisées. Le signal \texttt{M\_Received} est également mis à jour pour refléter l’état du bit correspondant.

\subsection{Interface de Réception LIN}

L’interface de réception LIN a été étudiée sous la forme d’une machine séquentielle, composée d’une partie opérative et d’une partie commande.
La partie opérative est développée sous la forme d’un schéma fonctionnel comprenant différents blocs tels que des multiplexeurs et des compteurs/décompteurs.
La partie commande, quant à elle, a été modélisée sous la forme d’un automate, traduit en machine de Moore, puis implémenté en VHDL.


\subsubsection{Partie opérative}

La partie opérative, déjà définie dans la section Description de la solution architecturale, a été reprise sous forme de blocs fonctionnels.
Il a simplement été nécessaire de reproduire le schéma global dans HDL Designer, afin d’assurer la cohérence entre la conception théorique et la modélisation pratique.

Le schéma correspondant est présenté ci-dessous :

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{images/presen/ReceptionTrameOP.png}
    \caption{Schéma partie opérative réception LIN}
    \label{fig:placeholder}
\end{figure}

Le decodeur présents avant le décompteurs DataField permet de de gérer la valeur chargé dans celui-ci.
Voici la table de vérité associée :

\begin{center}
\renewcommand{\arraystretch}{1.2} % espace vertical
\small % uniformise la taille du texte
\begin{tabularx}{\textwidth}{|X||X|}
\hline			
\textbf{OctetRecu} & \textbf{Decode\_OUT} \\ \hline 
00 & 001 \\
01 & 001 \\
10 & 010 \\
11 & 100 \\ 
\hline 
\end{tabularx}
\end{center}

Voici aussi le tableau des entrées et sorties de la partie opérative : 

\begin{table}[H]
\centering
\begin{tabular}{|l||c|l|}
\hline
\textbf{Signal} & \textbf{Direction} & \textbf{Type} \\ \hline
H                  & IN     & std\_logic \\ \hline
Identifien\_EN     & IN     & std\_logic \\ \hline
LIN                & IN     & std\_logic \\ \hline
NbBit\_EN          & IN     & std\_logic \\ \hline
NbBit\_LOAD        & IN     & std\_logic \\ \hline
NbBit\_SELECT      & IN     & std\_logic \\ \hline
NbDataField\_EN    & IN     & std\_logic \\ \hline
NbDataField\_Load  & IN     & std\_logic \\ \hline
OctetRecu\_EN      & IN     & std\_logic \\ \hline
nCLR               & IN     & std\_logic \\ \hline
n\_EN              & IN     & std\_logic \\ \hline
n\_LOAD            & IN     & std\_logic \\ \hline
n\_SELECT          & IN     & std\_logic \\ \hline
Identifieur        & OUT    & std\_logic\_vector(7 DOWNTO 0) \\ \hline
LinSynchro         & OUT    & std\_logic \\ \hline
NbDataField        & OUT    & std\_logic\_vector(2 DOWNTO 0) \\ \hline
NbDataField\_0     & OUT    & std\_logic \\ \hline
NbTBit\_0          & OUT    & std\_logic \\ \hline
NbTbit             & OUT    & std\_logic\_vector(3 DOWNTO 0) \\ \hline
OctetRecu          & OUT    & std\_logic\_vector(7 DOWNTO 0) \\ \hline
n                  & OUT    & std\_logic\_vector(11 DOWNTO 0) \\ \hline
n\_0               & OUT    & std\_logic \\ \hline
\end{tabular}
\caption{Signaux du module (partie opérative de réception LIN)}
\label{tab:signaux_lin}
\end{table}

\subsubsection{Partie Commande}

La partie commande consiste principalement à \textbf{traduire l’automate} présenté en figure~\ref{fig:automatereceptionlin} en \textbf{code VHDL}.  
Cette étape reste relativement simple, car elle repose sur la création de \textbf{trois processus principaux} :

\begin{enumerate}
    \item \textbf{Le réseau combinatoire d’entrée}, chargé de déterminer les \textit{états futurs} de l’automate en fonction des \textit{états présents} et des \textit{signaux d’entrée}.
    \item \textbf{Le réseau de registres}, synchronisé sur l’horloge, permettant de \textit{mémoriser les états} et d’assurer la transition entre les \textit{états présents} et les \textit{états futurs}.
    \item \textbf{Le réseau combinatoire de sortie}, qui met à jour les \textit{signaux de sortie} en fonction de l’état courant de l’automate.
\end{enumerate}

Voici le code suivant qui permet de traduire l'automate : 
\newline

\begin{lstlisting}[style=VHDLStyle, caption={Declaration des états}]
-- Etat de la machine
type CFM is (
    R_BRK_0, R_BRK_1,                -- Reception Break
    SYN_A, SYN_RST, SYN_RD, SYN_RSP, -- Synchro
    IDN_A, IDN_RST, IDN_RD, IDN_RSP, -- Identifier
    DAT_A, DAT_RST, DAT_RD, DAT_RSP, -- Datafield
    CHK_A, CHK_RST, CHK_RD, CHK_RSP, -- Checksum
    REPOS                            -- Repos
);
\end{lstlisting}

Dans une première étape, nous déclarons les différents états de l’automate sous la forme d’un type énuméré nommé \texttt{CFM}.
Chaque état correspond à une étape spécifique du processus de réception LIN, facilitant ainsi la gestion des transitions et des actions associées à chaque état.
\newline


\begin{lstlisting}[style=VHDLStyle, caption={Registres Reception Trame}]
-- Register
CFM_Register : process(H, nCLR)
begin
    if nCLR = '0' then
        P_CFM <= REPOS;
    elsif rising_edge(H) then
        P_CFM <= N_CFM;
    end if;
end process CFM_Register;
\end{lstlisting}

Dans ce code nous retrouvons la clock qui permet de synchroniser les états de l'automate avec le signal d'horloge H.
Le changement d'état se fait au front montant de l'horloge.
Le reset asynchrone nCLR permet de remettre l'automate dans son état initial
\newline

\begin{lstlisting}[style=VHDLStyle, caption={Réseau Combinatoire d’Entrée Reception Trame}]
-- Reseau Combinatoire d'Entree
CFM_RCE : process(P_CFM, H, Identifier, LinSynchro, NbTbit_0, NbDataField_0, SelAdr, nCLR, n_0)
begin
    -- Next State <= Present State
    N_CFM <= P_CFM;

    case P_CFM is
        when REPOS => -- Attente
            if LinSynchro = '0' then
                N_CFM <= R_BRK_0;
            end if;
        when R_BRK_0 => -- Synchro Break 0
            if NbTbit_0 = '1' AND LinSynchro = '1' then
                N_CFM <= R_BRK_1;
            elsif NbTbit_0 = '0' AND LinSynchro = '1' then
                N_CFM <= REPOS;
            elsif n_0 = '0' AND LinSynchro = '0' AND NbTbit_0 = '0' then
                N_CFM <= R_BRK_0;
            elsif NbTbit_0 = '0' AND LinSynchro = '0' AND n_0 = '1' then
                N_CFM <= R_BRK_0;
            end if;
        when R_BRK_1 => -- Synchro Break 1
            if n_0 = '1' AND LinSynchro = '1' then
                N_CFM <= SYN_A;
            elsif n_0 = '0' AND LinSynchro = '0' then
                N_CFM <= REPOS;
            elsif n_0 = '0' then
                N_CFM <= R_BRK_1;
            end if;
        when SYN_A => -- Attente bit Start Synchronisation
            if LinSynchro = '0' then
                N_CFM <= SYN_RST;
            end if;
        when SYN_RST => -- Reception Start Synchronisation
            if n_0 = '0' AND LinSynchro = '0' then
                N_CFM <= SYN_RD;
            elsif n_0 = '0' AND LinSynchro = '1' then
                N_CFM <= REPOS;
            elsif n_0 = '0' then
                N_CFM <= SYN_RST;
            end if;
        when SYN_RD => -- Reception Data Synchronisation
            if NbTbit_0 = '1' then
                N_CFM <= SYN_RSP;
            elsif n_0 = '1' AND NbTbit_0 = '0' then
                N_CFM <= SYN_RD;
            elsif n_0 = '0' then
                N_CFM <= SYN_RD;
            end if;
        when SYN_RSP => -- Reception bit Stop Synchronisation
            if n_0 = '1' AND LinSynchro = '1' then
                N_CFM <= IDN_A;
            elsif n_0 = '0' AND NbTbit_0 = '0' then
                N_CFM <= REPOS;
            elsif n_0 = '0' then
                N_CFM <= SYN_RSP;
            end if;
        when IDN_A => -- Attente bit Start Identifier
            if LinSynchro = '0' then
                N_CFM <= IDN_RST;
            end if;
        when IDN_RST => -- Reception bit Start Identifier
            if n_0 = '1' AND LinSynchro = '0' then
                N_CFM <= IDN_RD;
            elsif n_0 = '1' AND LinSynchro = '1' then
                N_CFM <= REPOS;
            elsif n_0 = '0' AND LinSynchro = '0' then
                N_CFM <= IDN_RST;
            end if;       
        when IDN_RD => -- Reception Data Identifier
            if NbTbit_0 = '1' AND n_0 = '1' then
                N_CFM <= IDN_RSP;
            elsif n_0 = '0' then
                N_CFM <= IDN_RD;
            elsif n_0 = '1' AND NbTbit_0 = '0' then
                N_CFM <= IDN_RD;
            end if;     
        when IDN_RSP => -- Reception bit Stop Identifier
            if n_0 = '1' AND LinSynchro = '1' then
                N_CFM <= DAT_A;
            elsif n_0 = '1' AND LinSynchro = '0' then
                N_CFM <= REPOS;
            elsif n_0 = '0' AND LinSynchro = '1' then
                N_CFM <= IDN_RSP;
            end if;   
        when DAT_A => -- Attente bit Start Datafield
            if LinSynchro = '0' then
                N_CFM <= DAT_RST;
            end if;   
        when DAT_RST => -- Reception bit Start Datafield
            if n_0 = '1' AND LinSynchro = '0' then
                N_CFM <= DAT_RD;
            elsif n_0 = '1' AND LinSynchro = '1' then
                N_CFM <= REPOS;
            elsif n_0 = '0' AND LinSynchro = '0' then
                N_CFM <= DAT_RST;
            end if;         
        when DAT_RD => -- Reception bit Data Datafield
            if NbTbit_0 = '1' AND LinSynchro = '1' then
                N_CFM <= DAT_RSP;
            elsif n_0 = '1' AND NbTbit_0 = '0' then
                N_CFM <= DAT_RD;
            elsif n_0 = '0' then
                N_CFM <= DAT_RD;
            end if;          
        when DAT_RSP => -- Reception bit Stop Datafield
		        if n_0 = '0' AND NbDataField_0 = '1' AND LinSynchro = '1' then
                N_CFM <= CHK_A;
            elsif NbDataField_0 = '0' AND n_0 = '1'AND LinSynchro = '1' then
                N_CFM <= DAT_A;
            elsif n_0 = '1' AND LinSynchro = '0' then
                N_CFM <= REPOS;
            elsif n_0 = '0' AND LinSynchro = '1'then
                N_CFM <= DAT_RSP;
            end if;   
        when CHK_A => -- Attente bit Start Checksum
            if LinSynchro = '0' then
                N_CFM <= CHK_RST;
            end if;           
        when CHK_RST => -- Reception bit Start Checksum
            if n_0 = '1' AND LinSynchro = '0' then
                N_CFM <= CHK_RD;
            elsif n_0 = '1' AND LinSynchro = '1' then
                N_CFM <= REPOS;
			elsif n_0 = '0' AND LinSynchro = '0' then
                N_CFM <= CHK_RST;
            end if;         
        when CHK_RD => -- Reception bit Data Checksum
            if NbTbit_0 = '1' AND LinSynchro = '1' then
                N_CFM <= CHK_RSP;
            elsif n_0 = '1' AND NbTbit_0 = '0' then
                N_CFM <= CHK_RD;
            elsif n_0 = '0' then
                N_CFM <= CHK_RD;
            end if;          
        when CHK_RSP => -- Reception bit Stop Checksum
            if n_0 = '1' AND LinSynchro = '1' AND Identifier = SelAdr then
                N_CFM <= REPOS; -- Fin de Trame Complete
            elsif n_0 = '1' AND LinSynchro = '1' AND Identifier /= SelAdr then
                N_CFM <= REPOS;
            elsif n_0 = '0' AND LinSynchro = '0' then
                N_CFM <= REPOS;
            elsif n_0 = '0' AND LinSynchro = '1' then
                N_CFM <= CHK_RSP;
            end if;               
    end case;
    
end process CFM_RCE;
\end{lstlisting}

Ce code VHDL traduit l’automate de réception LIN en utilisant un processus combinatoire nommé \texttt{CFM\_RCE}.
Il détermine l’état suivant (\texttt{N\_CFM}) en fonction de l’état actuel (\texttt{P\_CFM}) et des signaux d’entrée tels que \texttt{LinSynchro}, \texttt{NbTbit\_0}, \texttt{Identifier}, etc.
Chaque état de l’automate est représenté par une branche dans la structure \texttt{CASE}, avec des conditions spécifiques pour les transitions entre états.
\newline

\begin{lstlisting}[style=VHDLStyle, caption={Réseau Combinatoire de Sortie Reception Trame}]
  -- Reseau Combinatoire de Sortie
CFM_RES : process(P_CFM, H, Identifier, LinSynchro, NbTbit_0, NbDataField_0, SelAdr, nCLR, n_0 )
begin
  -- Valeurs par defaut
  Error_Start       <= '0';
  Error_Stop        <= '0';
  Error_Synchro     <= '0';
  Identifieur_en    <= '0';
  IncNbOctet        <= '0';
  MessageReceiveSet <= '0';
  NbDataField_EN    <= '0';
  NbDataField_load  <= '0';
  NbOcyeyRecu_RST   <= '0';
  OctetRecu_RST     <= '0';
  OctetRecu_WR      <= '0';
  OctetRecu_en      <= '0';
  n_Tbit_Load       <= '0';
  n_Tbit_en         <= '0';
  n_Tbit_select     <= '0';
  n_en              <= '0';
  n_load            <= '0';
  n_select          <= '0';

  case P_CFM is 
    when REPOS => -- Attente
      if LinSynchro = '0' then 
        n_select       <= '0';
        n_load         <= '1';
        n_en           <= '1';
        n_Tbit_select  <= '0';
        n_Tbit_en      <= '1';
        n_Tbit_Load    <= '1';
      end if;

    when R_BRK_0 => -- Synchro Break 0
      if NbTbit_0 = '1' and LinSynchro = '1' then
        n_select <= '0';
        n_en     <= '1';
        n_load   <= '1';
      elsif NbTbit_0 = '0' and LinSynchro = '1' then
        Error_Synchro <= '1';
      elsif NbTbit_0 = '0' and LinSynchro = '0' and n_0 = '1' then
        n_Tbit_en <= '1';
        n_select  <= '0';
        n_load    <= '1';
        n_en      <= '1';
      elsif n_0 = '0' AND LinSynchro = '0' AND NbTbit_0 = '0' then 
         n_en <= '1';
      end if;

    when R_BRK_1 => -- Synchro Break 1 
      if n_0 = '1' and LinSynchro = '0' then
        -- Nothing
      elsif n_0 = '0' and LinSynchro = '0' then
        Error_Synchro <= '1';
      elsif n_0 = '0' then
        n_en <= '1';
      end if;
      
    when SYN_A => -- Attente bit Start Synchronisation
        if LinSynchro = '0' then
            n_select  <= '0';
            n_load    <= '1';
            n_en      <= '1';
        end if;
        
    when SYN_RST => -- Reception Start Synchronisation
        if n_0 = '0' AND LinSynchro = '0' then
            n_select       <= '1'; -- passage de fin de front a milieu bit
            n_load         <= '1';
            n_en           <= '1';
            n_Tbit_select  <= '1';
            n_Tbit_en      <= '1';
            n_Tbit_Load    <= '1';
        elsif n_0 = '0' AND LinSynchro = '1' then
            Error_Start    <= '1';
        elsif n_0 = '0' then
            n_en           <= '1';
        end if;
        
    when SYN_RD => -- Reception Data Synchronisation
        if NbTbit_0 = '1' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
        elsif n_0 = '1' AND NbTbit_0 = '0' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
            n_Tbit_en      <= '1';
            OctetRecu_en   <= '1';
        elsif n_0 = '0' then
            n_en           <= '1';
        end if;
        
    when SYN_RSP => -- Reception bit Stop Synchronisation
        if n_0 = '1' AND LinSynchro = '1' then
            OctetRecu_WR   <= '1';
            n_select       <= '1';
            n_load         <= '1';
            n_en           <= '1';
        elsif n_0 = '0' AND NbTbit_0 = '0' then
            Error_Stop     <= '1';
        elsif n_0 = '0' then
            n_en           <= '1';
        end if;
        
    when IDN_A => -- Attente bit Start Identifier
        if LinSynchro = '0' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
        end if;
        
    when IDN_RST => -- Reception bit Start Identifier
        if n_0 = '1' AND LinSynchro = '0' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
            n_Tbit_select  <= '1';
            n_Tbit_Load    <= '1';
            n_Tbit_en      <= '1';
        elsif n_0 = '1' AND LinSynchro = '1' then
            Error_Start    <= '1';
        elsif n_0 = '0' AND LinSynchro = '0' then
            n_en           <= '1';
        end if;   
            
    when IDN_RD => -- Reception Data Identifier
        if NbTbit_0 = '1' AND n_0 = '1' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
			OctetRecu_en   <= '1';
        elsif n_0 = '0' then
            n_en           <= '1';
        elsif n_0 = '1' AND NbTbit_0 = '0' then
			n_select       <= '0';
			n_load         <= '1';
            n_en           <= '1';
			n_Tbit_en      <= '1';
            OctetRecu_en   <= '1';
        end if; 
            
    when IDN_RSP => -- Reception bit Stop Identifier
        if n_0 = '1' AND LinSynchro = '1' then
            OctetRecu_en   <= '1';
			      NbDataField_EN <= '1';
			      Identifieur_en <= '1';
			      NbDataField_load <= '1';
        elsif n_0 = '0' AND LinSynchro = '0' then
            Error_Stop     <= '1';
        elsif n_0 = '0' AND LinSynchro = '1' then
            n_select       <= '0';
            n_load         <= '0';
            n_en           <= '1';
        end if;   
        
    when DAT_A => -- Attente bit Start Datafield
        if LinSynchro = '0' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
        end if;   
        
    when DAT_RST => -- Reception bit Start Datafield
        if n_0 = '1' AND LinSynchro = '0' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
            n_Tbit_select  <= '1';
            n_Tbit_Load    <= '1';
            n_Tbit_en      <= '1';
        elsif n_0 = '1' AND LinSynchro = '1' then
            Error_Start    <= '1';
        elsif n_0 = '0' AND LinSynchro = '0' then
            n_en           <= '1';
        end if;  
               
    when DAT_RD => -- Reception bit Data Datafield
        if NbTbit_0 = '1' AND LinSynchro = '1' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
            OctetRecu_en   <= '1';
        elsif n_0 = '0' then
            n_en           <= '1';
        elsif n_0 = '1' AND NbTbit_0 = '0' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
            n_Tbit_en      <= '1';
            OctetRecu_en   <= '1';
        end if; 
                 
   	when DAT_RSP => -- Reception bit Stop Datafield
		    if n_0 = '0' AND NbDataField_0 = '1' AND LinSynchro = '1' then
    			   OctetRecu_WR   <= '1';
    			   n_select       <= '0';
    			   n_load         <= '1';
    			   n_en           <= '1';
    			   IncNbOctet     <= '1';
    		  elsif NbDataField_0 = '0' AND n_0 = '1'AND LinSynchro = '1' then
    			   OctetRecu_WR   <= '1';
    			   NbDataField_EN <= '1';
    			   n_select       <= '0';
    			   n_load         <= '1';
    			   n_en           <= '1';
    			   IncNbOctet     <= '1';
    		  elsif n_0 = '1' AND LinSynchro = '0' then
    		    Error_Stop     <= '1';
 		    elsif n_0 = '0' AND LinSynchro = '1'then
    			   n_en           <= '1';
    		end if;  
          
    when CHK_A => -- Attente bit Start Checksum
        if LinSynchro = '0' then
            n_select       <= '0';
            n_load         <= '1';
            n_en           <= '1';
        end if;   
                
    when CHK_RST => -- Reception bit Start Checksum
    		if n_0 = '1' AND LinSynchro = '0' then
                n_select       <= '0';
                n_load         <= '1';
                n_en           <= '1';
                n_Tbit_select  <= '1';
    		elsif n_0 = '1' AND LinSynchro = '1' then
                Error_Start    <= '1';
    		elsif n_0 = '0' AND LinSynchro = '0' then
                n_en           <= '1';
      end if;  
               
    when CHK_RD => -- Reception bit Data Checksum
    		if NbTbit_0 = '1' AND LinSynchro = '1' then
                n_select       <= '0';
                n_load         <= '1';
                n_en           <= '1';
    		elsif n_0 = '1' AND NbTbit_0 = '0' then
                n_en           <= '1';
    		elsif n_0 = '0' then
                n_Tbit_en      <= '1';
                n_select       <= '0';
                n_load         <= '1';
                n_en           <= '1';
                OctetRecu_en   <= '1';
                Identifieur_en    <= '1';
                NbDataField_load  <= '1';
                NbDataField_EN    <= '1';
      end if;  
                
    when CHK_RSP => -- Reception bit Stop Checksum
        if n_0 = '0' AND LinSynchro = '1' AND Identifier = SelAdr then
            MessageReceiveSet <= '1';
            NbOcyeyRecu_RST   <= '1';
        elsif n_0 = '0' AND LinSynchro = '1' AND Identifier /= SelAdr then
            MessageReceiveSet <= '1';
            NbOcyeyRecu_RST   <= '1';
        elsif n_0 = '0' AND LinSynchro = '0' then
            Error_Stop     <= '1';
        elsif n_0 = '0' then
            n_en           <= '1';
        end if;                         
        
    when others =>
      -- Sec 
      null;
  end case;
end process CFM_RES;
\end{lstlisting}

Ce code VHDL implémente le réseau combinatoire de sortie (\texttt{CFM\_RES}) pour l’automate de réception LIN.
Il met à jour les signaux de sortie tels que \texttt{Error\_Start}, \texttt{Error\_Stop}, \texttt{OctetRecu\_WR}, etc., en fonction de l’état actuel (\texttt{P\_CFM}) et des signaux d’entrée.
Chaque état de l’automate est géré dans une structure \texttt{CASE}, avec des conditions spécifiques pour définir les actions à entreprendre dans chaque état.
Des valeurs par défaut sont également définies au début du processus pour éviter des comportements indésirlés.  
\newline

Voici un tableau recapitulant les entrées et les sorties du bloc Repetion LIN partie commande : 
\newline

\begin{table}[H]
\centering
\begin{tabular}{|l||c|l|}
\hline
\textbf{Signal} & \textbf{Direction} & \textbf{Type} \\ \hline
H                 & IN     & std\_logic \\ \hline
Identifier        & IN     & std\_logic\_vector(7 DOWNTO 0) \\ \hline
LinSynchro        & IN     & std\_logic \\ \hline
NbTbit\_0         & IN     & std\_logic \\ \hline
NbDataField\_0     & IN     & std\_logic \\ \hline
SelAdr            & IN     & std\_logic\_vector(7 DOWNTO 0) \\ \hline
nCLR              & IN     & std\_logic \\ \hline
n\_0              & IN     & std\_logic \\ \hline
Error\_Start       & OUT    & std\_logic \\ \hline
Error\_Stop        & OUT    & std\_logic \\ \hline
Error\_Synchro     & OUT    & std\_logic \\ \hline
Identifieur\_en    & OUT    & std\_logic \\ \hline
IncNbOctet         & OUT    & std\_logic \\ \hline
MessageReceiveSet  & OUT    & std\_logic \\ \hline
NbDataField\_EN    & OUT    & std\_logic \\ \hline
NbDataField\_load  & OUT    & std\_logic \\ \hline
NbOcyeyRecu\_RST   & OUT    & std\_logic \\ \hline
OctetRecu\_RST     & OUT    & std\_logic \\ \hline
OctetRecu\_WR      & OUT    & std\_logic \\ \hline
OctetRecu\_en      & OUT    & std\_logic \\ \hline
n\_Tbit\_Load       & OUT    & std\_logic \\ \hline
n\_Tbit\_en         & OUT    & std\_logic \\ \hline
n\_Tbit\_select     & OUT    & std\_logic \\ \hline
n\_en              & OUT    & std\_logic \\ \hline
n\_load            & OUT    & std\_logic \\ \hline
n\_select          & OUT    & std\_logic \\ \hline
\end{tabular}
\caption{Signaux du module (partie commande de réception LIN)}
\label{tab:signaux_lin_reception}
\end{table}

Une fois ces processus implémentés, il nous reste qu'a les assemblés pour ne formé qu'une machine Complete.
\newline

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{images/presen/ReceptionTrameSeq.png}
    \caption{Machine Séquentielle réception LIN}
    \label{fig:placeholder}
\end{figure}

Le schéma complet de l’interface de réception LIN est présenté ci-dessus, illustrant l’intégration des différentes parties opératives et commandes ( Répresentant la machine séquentielle ).
\newline

Voici le tableau des entrées et sorties du bloc Repetion LIN complet :
\newline

\begin{table}[H]
\centering
\begin{tabular}{|l||c|l|}
\hline
\textbf{Signal} & \textbf{Direction} & \textbf{Type} \\ \hline
H                  & IN     & std\_logic \\ \hline
Lin                & IN     & std\_logic \\ \hline
SelAdr             & IN     & std\_logic\_vector(7 DOWNTO 0) \\ \hline
nCLR               & IN     & std\_logic \\ \hline
Error\_Start       & OUT    & std\_logic \\ \hline
Error\_Stop        & OUT    & std\_logic \\ \hline
Error\_Synchro     & OUT    & std\_logic \\ \hline
IncNbOctet         & OUT    & std\_logic \\ \hline
MessageReceiveSet  & OUT    & std\_logic \\ \hline
NbOcyeyRecu\_RST   & OUT    & std\_logic \\ \hline
OctetRecu          & OUT    & std\_logic\_vector(7 DOWNTO 0) \\ \hline
OctetRecu\_RST     & OUT    & std\_logic \\ \hline
OctetRecu\_WR      & OUT    & std\_logic \\ \hline
\end{tabular}
\caption{Signaux du module (partie réception LIN)}
\label{tab:signaux_lin_reception2}
\end{table}



\subsection{FIFO}

La mémoire FIFO (First In, First Out) a été conçue pour stocker temporairement les données reçues via l’interface LIN avant leur traitement ultérieur.
Elle est structurée autour d'un composant clef, la FIFO.
Cette section à été réaliser sur un schéma blocs, en reprenant les concepts vus en cours.
\newline

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{images/presen/FIFO.png}
    \caption{Schéma bloc FIFO}
    \label{fig:placeholder}
\end{figure}

Voici le tableau des entrées et sorties du bloc FIFO :
\newline

\begin{table}[H]
\centering
\begin{tabular}{|l||c|l|}
\hline
\textbf{Signal} & \textbf{Direction} & \textbf{Type} \\ \hline
H              & IN     & std\_logic \\ \hline
OctetLu\_RD    & IN     & std\_logic \\ \hline
OctetRecu      & IN     & std\_logic\_vector(7 DOWNTO 0) \\ \hline
OctetRecu\_RST & IN     & std\_logic \\ \hline
OctetRecu\_WR  & IN     & std\_logic \\ \hline
nCLR           & IN     & std\_logic \\ \hline
OctetLu        & OUT    & std\_logic\_vector(7 DOWNTO 0) \\ \hline
\end{tabular}
\caption{Signaux du module (lecture des octets LIN)}
\label{tab:signaux_lin_octetlu}
\end{table}


\subsection{Etat Interne}

Etat interne est un composant VHDL qui gère les états internes du système de réception LIN. 
Le systeme à été conçu pour suivre et contrôler les différentes étapes du processus de réception des trames LIN.
L'Objectifs étant d'additionner des fonctionnalités de contrôle et de gestion des états internes pour ne formé qu'une seul trame.
\newline

Ce systeme à lui aussi été conçu sous la forme d'un schéma bloc, reprenant les concepts vus en cours. Avec des bascules D, des compteurs et l'ajout de OR pour gérer les RESET.
\newline

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{images/presen/ETAT_INTERNE.png}
    \caption{Schéma bloc EtatInterne}
    \label{fig:placeholder}
\end{figure}

Le module de Decode présent avant le compteur/decompteur permet de savoir si il doit compter ou décompter. Ce signal sera généré en fonction des états des signaux de la partie commande.

\begin{center}
\renewcommand{\arraystretch}{1.2} % espace vertical
\small % uniformise la taille du texte
\begin{tabularx}{\textwidth}{|X|X||X|}
\hline			
\textbf{NbTbitInc} & \textbf{NbTbitDec} & \textbf{UP/DN} \\ \hline 
0 & 0 & X \\
0 & 1 & 1 \\
0 & 0 & 0 \\
1 & 1 & X \\ 
\hline 
\end{tabularx}
\end{center}

Voici le tableau des entrées et sorties du bloc Etat Interne :
\newline

\begin{table}[H]
\centering
\begin{tabular}{|l||c|l|}
\hline
\textbf{Signal} & \textbf{Direction} & \textbf{Type} \\ \hline
ErrorStart          & IN     & std\_logic \\ \hline
ErrorStop           & IN     & std\_logic \\ \hline
ErrorSynchro        & IN     & std\_logic \\ \hline
H                   & IN     & std\_logic \\ \hline
MessageReceive\_SET & IN     & std\_logic \\ \hline
NbTbitDec           & IN     & std\_logic \\ \hline
NbTbitInc           & IN     & std\_logic \\ \hline
NbTbit\_RST         & IN     & std\_logic \\ \hline
ReadStatus\_RST     & IN     & std\_logic \\ \hline
nCLR                & IN     & std\_logic \\ \hline
EtatLu              & OUT    & std\_logic\_vector(7 DOWNTO 0) \\ \hline
\end{tabular}
\caption{Signaux du module (lecture de l'état LIN)}
\label{tab:signaux_lin_etatlu}
\end{table}

\subsection{Réception LIN Complete}

Après avoir développé les différentes parties du système de réception LIN, nous procédons à l’intégration de ces composants pour former une unité cohérente et fonctionnelle.
\newline

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{images/presen/RecepteurLIN.png}
    \caption{Schéma bloc Réception LIN Complete}
    \label{fig:placeholder}
\end{figure}

On retrouve les différentes parties vues précédemment, à savoir l’interface de réception LIN, la mémoire FIFO et le module d’état interne.